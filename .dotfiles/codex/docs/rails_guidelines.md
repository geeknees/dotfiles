# Ruby on Rails Coding Guidelines (for Coding Agents)
## Preface

This document defines **normative and practical guidelines** for coding agents to systematically generate **high-quality Ruby on Rails applications** with strong **consistency, maintainability, and extensibility**. These guidelines are designed to be applicable across projects of any scale—from small prototypes to large enterprise systems.

The foundation of this guideline is rooted in two core Rails philosophies:

- **Convention over Configuration (CoC)**
    
- **DRY (Don’t Repeat Yourself)**
    

A deep understanding and disciplined adherence to these principles is essential to unlocking Rails’ full potential and accelerating development. This guideline aims to translate those philosophies into concrete coding practices to enable efficient, robust application development.

---

## 1. Core Principles

Understanding the core principles that form the intellectual foundation of Rails development is the first step toward building a productive and consistent codebase. These principles are not arbitrary rules; they are distilled from long-standing software engineering knowledge and guide the overall system design.

### 1.1 MVC (Model–View–Controller) Architecture

All Rails applications **MUST** be implemented using the MVC architecture. MVC separates concerns clearly, improving organization, reusability, and testability. Responsibilities are strictly defined as follows:

- **Model**  
    The Model is fully responsible for **business logic and data persistence**. In Rails, **Active Record** serves as the ORM layer, mapping database tables to Ruby objects. Core logic—such as validation, calculations, state transitions, and integrations with external services—**MUST** be concentrated in the Model.
    
- **View**  
    The View is dedicated to **presentation/UI rendering**. Its sole responsibility is to format and display data passed from the Controller (typically as HTML). Views **MUST NOT** contain business logic. Only minimal presentation logic (simple conditionals/loops) is permitted.
    
- **Controller**  
    The Controller coordinates between Models and Views. It receives HTTP requests, interprets them, invokes the appropriate Model operations, and decides which View to render. The principle **“Fat Model, Skinny Controller” MUST be enforced**. This separation is not just organizational—it is critical for maintainability and testability:
    
    - Business logic in Models can be unit-tested independently of HTTP concerns.
        
    - Controllers bloated with business logic become hard to test and fragile to change.
        

### 1.2 Convention over Configuration (CoC)

Rails is built to minimize configuration by relying on conventions. For example:

- A `LineItem` model maps to the `line_items` table.
    
- A `LineItemsController` maps naturally to the `line_items` resource.
    

By following naming and structural conventions, Rails can wire components automatically, allowing developers to focus on core functionality. Following conventions is one of the most effective ways to maximize productivity.

### 1.3 DRY (Don’t Repeat Yourself)

The DRY principle states that the same knowledge should not be duplicated within the system. Duplication increases maintenance cost and becomes a breeding ground for bugs.

If a logic block is copied across multiple places, a future change requires all copies to be updated correctly. DRY requires extracting shared knowledge into methods, modules, and reusable abstractions to keep the codebase concise and resilient.

### 1.4 RESTful Design

Rails routing and controller design are strongly influenced by REST (Representational State Transfer). The system should be modeled as a set of **resources**, operated through HTTP verbs (`GET`, `POST`, `PUT/PATCH`, `DELETE`).

Using `resources` generates the standard seven actions:

- `index` — list resources
    
- `show` — show a single resource
    
- `new` — show form for a new resource
    
- `create` — create a resource
    
- `edit` — show form to edit a resource
    
- `update` — update a resource
    
- `destroy` — delete a resource
    

Following REST conventions produces intuitive, consistent, and predictable URLs and APIs. Deviations (custom actions) **MUST** be deliberate and justified, since they trade predictability for flexibility.

These principles provide the foundation for all subsequent sections.

---

## 2. Ruby Language Conventions

To ensure consistency across a Rails application, Ruby-level conventions are essential. A unified style dramatically improves readability and helps maintain quality across a codebase generated by multiple agents.

### 2.1 Naming Conventions

The following naming rules **MUST** be strictly followed:

- **Variables & methods:** `snake_case`  
    Examples: `line_item`, `calculate_total_price`
    
- **Classes & modules:** `CamelCase`  
    Examples: `PurchaseOrder`, `BillingHelper`
    
- **Constants:** `UPPER_CASE`  
    Examples: `DEFAULT_PRICE`, `MAX_LOGIN_ATTEMPTS`
    
- **Filenames:** `snake_case.rb`, matching class/module name for Rails autoloading  
    Example: `PurchaseOrder` MUST be defined in `purchase_order.rb`
    

### 2.2 Coding Style

- **Indentation:** use **2 spaces**. Tabs **MUST NOT** be used.
    
- **Parentheses in method calls:**  
    Rails culture often omits parentheses for brevity (especially in view helpers). Omission is acceptable only when it does not reduce clarity. If calls are chained or arguments may be ambiguous, parentheses **MUST** be used.
    
- **String literals:**  
    Choose quotes by intent:
    
    - **Single quotes (`'...'`)** for static strings (no interpolation, no escapes).
        
    - **Double quotes (`"..."`)** for interpolation (`#{...}`) or escape sequences (`\n`).
        

These Ruby conventions form the base of all Rails component guidelines.

---

## 3. Model (Active Record) Guidelines

Models contain the application’s business core. Their design quality directly determines robustness, maintainability, and long-term value. Clean models with clear responsibilities are a top priority.

### 3.1 Responsibilities and Placement

- Model source files **MUST** reside under `app/models/`.
    
- **Business logic MUST be centralized in Models**, including:
    
    - calculations
        
    - complex query composition
        
    - state management
        
    - external API coordination (where appropriate)
        

This enables the “Fat Model, Skinny Controller” structure.

### 3.2 Associations

Associations **MUST** be declared using Active Record macros (`belongs_to`, `has_many`, `has_one`, `has_and_belongs_to_many`). These provide a powerful abstraction layer enabling object navigation (e.g., `order.line_items`) without writing raw JOIN-heavy SQL.

### 3.3 Validations

Data integrity **MUST** be enforced at the model layer using `validates`. Use built-in helpers whenever possible:

- `presence`
    
- `uniqueness`
    
- `format`
    
- `numericality`
    
- etc.
    

Custom validations should be introduced only when necessary. Validation logic **MUST NOT** be implemented in controllers or views.

### 3.4 Scopes

Frequently used queries **MUST** be defined as named scopes in the Model. Scopes encapsulate query conditions into reusable, composable methods.

**Controller without scopes:**

```ruby
# products_controller.rb
def index
  @products = Product.where(discontinued: false).order(created_at: :desc)
end
```

**Model + controller using scopes:**

```ruby
# product.rb
class Product < ApplicationRecord
  scope :available, -> { where(discontinued: false) }
  scope :recent, -> { order(created_at: :desc) }
end

# products_controller.rb
def index
  @products = Product.available.recent
end
```

This makes controllers more declarative, improves readability, and increases reuse.

### 3.5 Callbacks

Active Record callbacks (e.g., `before_save`, `after_create`) are powerful but risky. Overuse makes behavior implicit and can cause “spooky action at a distance,” complicating debugging.

- **Appropriate use:** self-contained logic depending only on the model’s internal state.
    
- **Inappropriate use:** complex external interactions (e.g., calling external APIs in `after_save`). This can make persistence unpredictable and complicate rollbacks.
    

Callbacks **MUST** be used sparingly and intentionally. Complex workflows should be implemented via explicit service classes.

---

## 4. View (Action View) Guidelines

Views are the user-facing interface. The most important principle is **strict separation between presentation and business logic**. This separation improves collaboration and makes future UI changes easier.

### 4.1 Separation of Logic

Complex Ruby logic inside templates (`.html.erb`, etc.) is **PROHIBITED**. Data preparation, filtering, and calculations **MUST** be completed before rendering—typically in Models, Controllers, or Helpers. Views are limited to rendering and minimal presentation logic.

### 4.2 Use of Helper Methods

Rails helper methods **MUST** be used for generating links and forms:

- `link_to` — instead of hardcoding `<a>` tags
    
- `form_for` / `form_with` — to generate correct forms tied to models and validations
    

These helpers reduce boilerplate, improve consistency, and strengthen resilience to routing changes.

### 4.3 Partial Templates

Reusable UI components (nav bars, cards, comment blocks) **MUST** be extracted into partials (files prefixed with `_`, e.g., `_product.html.erb`). This enforces DRY in the view layer and improves maintainability.

### 4.4 Layouts

Site-wide structure (header/footer/sidebar) **MUST** be managed in layout files, typically `app/views/layouts/application.html.erb`. Content from individual actions is injected via `yield`. This centralizes global design changes.

---

## 5. Controller (Action Controller) Guidelines

Controllers are traffic coordinators. Keeping responsibilities narrow is essential for clean, testable, easy-to-understand systems.

### 5.1 Responsibilities (Skinny Controller)

Controllers **MUST** be limited to the following five responsibilities:

1. Receive parameters and session data (`params`, session)
    
2. Perform authentication and authorization
    
3. Query/update Models (without implementing business logic)
    
4. Pass data to Views via instance variables (e.g., `@products`)
    
5. Determine the response (`render` or `redirect_to`)
    

All other logic—especially business logic—**MUST** live in Models or service objects.

### 5.2 RESTful Actions

Resource controllers **MUST** use the standard REST actions (`index`, `show`, `new`, `create`, `edit`, `update`, `destroy`) by default. Custom actions should be added only when REST cannot express the intent.

### 5.3 Session and Flash

- **Session:** store small cross-request data (e.g., `user_id`). Avoid storing large data or complex objects.
    
- **Flash:** store one-time messages that survive redirects (e.g., “Created successfully”). Flash entries are cleared after the next request.
    

### 5.4 Filters (before_action)

Shared preprocessing logic (authentication, loading records) **MUST** be extracted into `before_action` filters to remove duplication.

```ruby
# products_controller.rb
class ProductsController < ApplicationController
  before_action :authenticate_user!, except: [:index, :show]
  before_action :set_product, only: [:show, :edit, :update, :destroy]

  def show
    # @product is already set by set_product
  end

  def edit
    # @product is already set by set_product
  end

  private

  def set_product
    @product = Product.find(params[:id])
  end
end
```

---

## 6. Testing Guidelines

Tests are not merely for QA—they enable confident refactoring and rapid development. DRY can be applied safely only when a reliable test suite protects against regressions.

### 6.1 Test Types and Responsibilities

Rails supports multiple test layers. They **MUST** be used appropriately:

- **Unit Tests:** primarily for Models. Validate method behavior, validations, scopes, and associations independently. This is the most important layer for business correctness.
    
- **Functional (Controller) Tests:** simulate HTTP requests to verify responses, templates, session, and flash behavior.
    
- **Integration Tests:** validate multi-step workflows across controllers/models (e.g., login → add to cart → checkout).
    

### 6.2 Fixtures

Sample data **MUST** be centrally managed as YAML fixtures under `test/fixtures/`. Fixtures ensure stable, reproducible test environments.

### 6.3 Running Tests

Any code change **MUST** be accompanied by execution of relevant tests to ensure no regressions. Run the full suite with:

```bash
rails test
```

A CI setup that runs tests on every push is strongly recommended.

### 6.4 Note on RSpec

This guideline focuses on Rails’ default test tooling based on the provided context. However, **RSpec** is widely adopted in the Rails community. The same test principles apply when using RSpec, even though the syntax differs (`describe`, `it`, `expect`, etc.).

---

## Conclusion

These guidelines are not an arbitrary list of rules. They represent a proven approach to building **professional-grade, resilient, and valuable software assets**. Compliance is a strategic investment in the future of the codebase—ensuring it remains clean, maintainable, and scalable as the business grows.

---

